var $ = require('jquery');
var browserFeatures = require('./feature-detection');
var clipboard = require('./clipboard');
var eventable = require('./eventable');
var SelectionWatcher = require('./selection-watcher');
var config = require('./config');
var Keyboard = require('./keyboard');

/**
 * The Dispatcher module is responsible for dealing with events and their handlers.
 *
 * @module core
 * @submodule dispatcher
 */

var Dispatcher = function(editable) {
  var win = editable.win;
  eventable(this, editable);
  this.supportsInputEvent = false;
  this.$document = $(win.document);
  this.config = editable.config;
  this.editable = editable;
  this.editableSelector = editable.editableSelector;
  this.selectionWatcher = new SelectionWatcher(this, win);
  this.keyboard = new Keyboard(this.selectionWatcher);
  this.setup();
};

module.exports = Dispatcher;

// This will be set to true once we detect the input event is working.
// Input event description on MDN:
// https://developer.mozilla.org/en-US/docs/Web/Reference/Events/input
var isInputEventSupported = false;

/**
 * Sets up all events that Editable.JS is catching.
 *
 * @method setup
 */
Dispatcher.prototype.setup = function() {
  // setup all events notifications
  this.setupElementEvents();
  this.setupKeyboardEvents();

  if (browserFeatures.selectionchange) {
    this.setupSelectionChangeEvents();
  } else {
    this.setupSelectionChangeFallback();
  }
};

Dispatcher.prototype.unload = function() {
  this.off();
  this.$document.off('.editable');
};

/**
 * Sets up events that are triggered on modifying an element.
 *
 * @method setupElementEvents
 * @param {HTMLElement} $document: The document element.
 * @param {Function} notifier: The callback to be triggered when the event is caught.
 */
Dispatcher.prototype.setupElementEvents = function() {
  var _this = this;
  this.$document.on('focus.editable', _this.editableSelector, function(event) {
    if (this.getAttribute(config.pastingAttribute)) return;
    _this.notify('focus', this);
  }).on('blur.editable', _this.editableSelector, function(event) {
    if (this.getAttribute(config.pastingAttribute)) return;
    _this.notify('blur', this);
  }).on('copy.editable', _this.editableSelector, function(event) {
    var selection = _this.selectionWatcher.getFreshSelection();
    if (selection.isSelection) {
      _this.notify('clipboard', this, 'copy', selection);
    }
  }).on('cut.editable', _this.editableSelector, function(event) {
    var selection = _this.selectionWatcher.getFreshSelection();
    if (selection.isSelection) {
      _this.notify('clipboard', this, 'cut', selection);
      _this.triggerChangeEvent(this);
    }
  }).on('paste.editable', _this.editableSelector, function(event) {
    var element = this;
    var afterPaste = function (blocks, cursor) {
      if (blocks.length) {
        _this.notify('paste', element, blocks, cursor);

        // The input event does not fire when we process the content manually
        // and insert it via script
        _this.notify('change', element);
      } else {
        cursor.setVisibleSelection();
      }
    };

    var cursor = _this.selectionWatcher.getFreshSelection();
    clipboard.paste(this, cursor, afterPaste);


  }).on('input.editable', _this.editableSelector, function(event) {
    if (isInputEventSupported) {
      _this.notify('change', this);
    } else {
      // Most likely the event was already handled manually by
      // triggerChangeEvent so the first time we just switch the
      // isInputEventSupported flag without notifiying the change event.
      isInputEventSupported = true;
    }
  }).on('formatEditable.editable', _this.editableSelector, function(event) {
    _this.notify('change', this);
  });
};

/**
 * Trigger a change event
 *
 * This should be done in these cases:
 * - typing a letter
 * - delete (backspace and delete keys)
 * - cut
 * - paste
 * - copy and paste (not easily possible manually as far as I know)
 *
 * Preferrably this is done using the input event. But the input event is not
 * supported on all browsers for contenteditable elements.
 * To make things worse it is not detectable either. So instead of detecting
 * we set 'isInputEventSupported' when the input event fires the first time.
 */
Dispatcher.prototype.triggerChangeEvent = function(target){
  if (isInputEventSupported) return;
  this.notify('change', target);
};

Dispatcher.prototype.dispatchSwitchEvent = function(event, element, direction) {
  var cursor;
  if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey)
    return;

  cursor = this.selectionWatcher.getSelection();
  if (!cursor || cursor.isSelection) return;
  // Detect if the browser moved the cursor in the next tick.
  // If the cursor stays at its position, fire the switch event.
  var dispatcher = this;
  setTimeout(function() {
    var newCursor = dispatcher.selectionWatcher.forceCursor();
    if (newCursor.equals(cursor)) {
      event.preventDefault();
      event.stopPropagation();
      dispatcher.notify('switch', element, direction, newCursor);
    }
  }, 1);
};

/**
 * Sets up events that are triggered on keyboard events.
 * Keyboard definitions are in {{#crossLink "Keyboard"}}{{/crossLink}}.
 *
 * @method setupKeyboardEvents
 * @param {HTMLElement} $document: The document element.
 * @param {Function} notifier: The callback to be triggered when the event is caught.
 */
Dispatcher.prototype.setupKeyboardEvents = function() {
  var _this = this;

  this.$document.on('keydown.editable', this.editableSelector, function(event) {
    var notifyCharacterEvent = !isInputEventSupported;
    _this.keyboard.dispatchKeyEvent(event, this, notifyCharacterEvent);
  });

  this.keyboard.on('left', function(event) {
    _this.dispatchSwitchEvent(event, this, 'before');
  }).on('up', function(event) {
    _this.dispatchSwitchEvent(event, this, 'before');
  }).on('right', function(event) {
    _this.dispatchSwitchEvent(event, this, 'after');
  }).on('down', function(event) {
    _this.dispatchSwitchEvent(event, this, 'after');
  }).on('tab', function(event) {
  }).on('shiftTab', function(event) {
  }).on('esc', function(event) {
  }).on('backspace', function(event) {
    var range = _this.selectionWatcher.getFreshRange();
    if (range.isCursor) {
      var cursor = range.getCursor();
      if ( cursor.isAtBeginning() ) {
        event.preventDefault();
        event.stopPropagation();
        _this.notify('merge', this, 'before', cursor);
      } else {
        _this.triggerChangeEvent(this);
      }
    } else {
      _this.triggerChangeEvent(this);
    }
  }).on('delete', function(event) {
    var range = _this.selectionWatcher.getFreshRange();
    if (range.isCursor) {
      var cursor = range.getCursor();
      if (cursor.isAtTextEnd()) {
        event.preventDefault();
        event.stopPropagation();
        _this.notify('merge', this, 'after', cursor);
      } else {
        _this.triggerChangeEvent(this);
      }
    } else {
      _this.triggerChangeEvent(this);
    }
  }).on('enter', function(event) {
    event.preventDefault();
    event.stopPropagation();
    var range = _this.selectionWatcher.getFreshRange();
    var cursor = range.forceCursor();

    if (cursor.isAtTextEnd()) {
      _this.notify('insert', this, 'after', cursor);
    } else if (cursor.isAtBeginning()) {
      _this.notify('insert', this, 'before', cursor);
    } else {
      _this.notify('split', this, cursor.before(), cursor.after(), cursor);
    }

  }).on('shiftEnter', function(event) {
    event.preventDefault();
    event.stopPropagation();
    var cursor = _this.selectionWatcher.forceCursor();
    _this.notify('newline', this, cursor);
  }).on('character', function(event) {
    _this.notify('change', this);
  });
};

/**
 * Sets up events that are triggered on a selection change.
 *
 * @method setupSelectionChangeEvents
 * @param {HTMLElement} $document: The document element.
 * @param {Function} notifier: The callback to be triggered when the event is caught.
 */
Dispatcher.prototype.setupSelectionChangeEvents = function() {
  var selectionDirty = false;
  var suppressSelectionChanges = false;
  var $document = this.$document;
  var selectionWatcher = this.selectionWatcher;
  var _this = this;

  // fires on mousemove (thats probably a bit too much)
  // catches changes like 'select all' from context menu
  $document.on('selectionchange.editable', function(event) {
    if (suppressSelectionChanges) {
      selectionDirty = true;
    } else {
      selectionWatcher.selectionChanged();
    }
  });

  // listen for selection changes by mouse so we can
  // suppress the selectionchange event and only fire the
  // change event on mouseup
  $document.on('mousedown.editable', this.editableSelector, function(event) {
    if (_this.config.mouseMoveSelectionChanges === false) {
      suppressSelectionChanges = true;

      // Without this timeout the previous selection is active
      // until the mouseup event (no. not good).
      setTimeout($.proxy(selectionWatcher, 'selectionChanged'), 0);
    }

    $document.on('mouseup.editableSelection', function(event) {
      $document.off('.editableSelection');
      suppressSelectionChanges = false;

      if (selectionDirty) {
        selectionDirty = false;
        selectionWatcher.selectionChanged();
      }
    });
  });
};


/**
 * Fallback solution to support selection change events on browsers that don't
 * support selectionChange.
 *
 * @method setupSelectionChangeFallback
 * @param {HTMLElement} $document: The document element.
 * @param {Function} notifier: The callback to be triggered when the event is caught.
 */
Dispatcher.prototype.setupSelectionChangeFallback = function() {
  var $document = this.$document;
  var selectionWatcher = this.selectionWatcher;

  // listen for selection changes by mouse
  $document.on('mouseup.editableSelection', function(event) {

    // In Opera when clicking outside of a block
    // it does not update the selection as it should
    // without the timeout
    setTimeout($.proxy(selectionWatcher, 'selectionChanged'), 0);
  });

  // listen for selection changes by keys
  $document.on('keyup.editable', this.editableSelector, function(event) {

    // when pressing Command + Shift + Left for example the keyup is only triggered
    // after at least two keys are released. Strange. The culprit seems to be the
    // Command key. Do we need a workaround?
    selectionWatcher.selectionChanged();
  });
};
